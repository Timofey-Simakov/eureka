// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const graphByUser = `-- name: GraphByUser :many
WITH mypages AS (
  SELECT id FROM pages WHERE user_id=$1::uuid
)
SELECT
  p.id::text   AS node_id,
  p.name       AS node_name,
  COALESCE(l.id_source::text, '') AS edge_from,
  COALESCE(l.id_dest::text, '')   AS edge_to,
  l.tag
FROM pages p
LEFT JOIN page_links l ON l.id_source=p.id OR l.id_dest=p.id
WHERE p.user_id=$1::uuid
`

type GraphByUserRow struct {
	NodeID   string         `json:"node_id"`
	NodeName string         `json:"node_name"`
	EdgeFrom interface{}    `json:"edge_from"`
	EdgeTo   interface{}    `json:"edge_to"`
	Tag      sql.NullString `json:"tag"`
}

func (q *Queries) GraphByUser(ctx context.Context, dollar_1 uuid.UUID) ([]GraphByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, graphByUser, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GraphByUserRow
	for rows.Next() {
		var i GraphByUserRow
		if err := rows.Scan(
			&i.NodeID,
			&i.NodeName,
			&i.EdgeFrom,
			&i.EdgeTo,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkCreate = `-- name: LinkCreate :one
INSERT INTO page_links (id_source,id_dest,tag) VALUES ($1::uuid,$2::uuid, NULLIF($3,''))
RETURNING id::text
`

type LinkCreateParams struct {
	Column1 uuid.UUID   `json:"column_1"`
	Column2 uuid.UUID   `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

func (q *Queries) LinkCreate(ctx context.Context, arg LinkCreateParams) (string, error) {
	row := q.db.QueryRowContext(ctx, linkCreate, arg.Column1, arg.Column2, arg.Column3)
	var id string
	err := row.Scan(&id)
	return id, err
}

const linkDelete = `-- name: LinkDelete :exec
DELETE FROM page_links WHERE id=$1::uuid
`

func (q *Queries) LinkDelete(ctx context.Context, dollar_1 uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, linkDelete, dollar_1)
	return err
}

const linksBySource = `-- name: LinksBySource :many
SELECT id::text, id_source::text, id_dest::text, tag FROM page_links WHERE id_source=$1::uuid
`

type LinksBySourceRow struct {
	ID       string         `json:"id"`
	IDSource string         `json:"id_source"`
	IDDest   string         `json:"id_dest"`
	Tag      sql.NullString `json:"tag"`
}

func (q *Queries) LinksBySource(ctx context.Context, dollar_1 uuid.UUID) ([]LinksBySourceRow, error) {
	rows, err := q.db.QueryContext(ctx, linksBySource, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LinksBySourceRow
	for rows.Next() {
		var i LinksBySourceRow
		if err := rows.Scan(
			&i.ID,
			&i.IDSource,
			&i.IDDest,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linksDeleteBySource = `-- name: LinksDeleteBySource :exec
DELETE FROM page_links WHERE id_source=$1::uuid
`

func (q *Queries) LinksDeleteBySource(ctx context.Context, dollar_1 uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, linksDeleteBySource, dollar_1)
	return err
}
