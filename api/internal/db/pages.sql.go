// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pages.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const pageByID = `-- name: PageByID :one
SELECT id::text, user_id::text AS owner_id, name, body, updated_at FROM pages WHERE id=$1::uuid
`

type PageByIDRow struct {
	ID        string    `json:"id"`
	OwnerID   string    `json:"owner_id"`
	Name      string    `json:"name"`
	Body      string    `json:"body"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) PageByID(ctx context.Context, dollar_1 uuid.UUID) (PageByIDRow, error) {
	row := q.db.QueryRowContext(ctx, pageByID, dollar_1)
	var i PageByIDRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Body,
		&i.UpdatedAt,
	)
	return i, err
}

const pageByNameAndUser = `-- name: PageByNameAndUser :one
SELECT id::text FROM pages WHERE user_id=$1::uuid AND name=$2 LIMIT 1
`

type PageByNameAndUserParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Name    string    `json:"name"`
}

func (q *Queries) PageByNameAndUser(ctx context.Context, arg PageByNameAndUserParams) (string, error) {
	row := q.db.QueryRowContext(ctx, pageByNameAndUser, arg.Column1, arg.Name)
	var id string
	err := row.Scan(&id)
	return id, err
}

const pageCreate = `-- name: PageCreate :one
INSERT INTO pages (user_id, name, body) VALUES ($1::uuid,$2,$3)
RETURNING id::text
`

type PageCreateParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Name    string    `json:"name"`
	Body    string    `json:"body"`
}

func (q *Queries) PageCreate(ctx context.Context, arg PageCreateParams) (string, error) {
	row := q.db.QueryRowContext(ctx, pageCreate, arg.Column1, arg.Name, arg.Body)
	var id string
	err := row.Scan(&id)
	return id, err
}

const pageDelete = `-- name: PageDelete :exec
DELETE FROM pages WHERE id=$1::uuid
`

func (q *Queries) PageDelete(ctx context.Context, dollar_1 uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, pageDelete, dollar_1)
	return err
}

const pageOwner = `-- name: PageOwner :one
SELECT user_id::text FROM pages WHERE id=$1::uuid
`

func (q *Queries) PageOwner(ctx context.Context, dollar_1 uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, pageOwner, dollar_1)
	var user_id string
	err := row.Scan(&user_id)
	return user_id, err
}

const pageSetOwner = `-- name: PageSetOwner :exec
UPDATE pages SET user_id=$2::uuid WHERE id=$1::uuid
`

type PageSetOwnerParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
}

func (q *Queries) PageSetOwner(ctx context.Context, arg PageSetOwnerParams) error {
	_, err := q.db.ExecContext(ctx, pageSetOwner, arg.Column1, arg.Column2)
	return err
}

const pageUpdate = `-- name: PageUpdate :exec
UPDATE pages SET name=$2, body=$3 WHERE id=$1::uuid
`

type PageUpdateParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Name    string    `json:"name"`
	Body    string    `json:"body"`
}

func (q *Queries) PageUpdate(ctx context.Context, arg PageUpdateParams) error {
	_, err := q.db.ExecContext(ctx, pageUpdate, arg.Column1, arg.Name, arg.Body)
	return err
}

const pagesAll = `-- name: PagesAll :many
SELECT p.id::text AS id, p.name, u.email AS owner_email, p.updated_at
FROM pages p JOIN users u ON u.id=p.user_id
ORDER BY p.updated_at DESC
`

type PagesAllRow struct {
	ID         string    `json:"id"`
	Name       string    `json:"name"`
	OwnerEmail string    `json:"owner_email"`
	UpdatedAt  time.Time `json:"updated_at"`
}

func (q *Queries) PagesAll(ctx context.Context) ([]PagesAllRow, error) {
	rows, err := q.db.QueryContext(ctx, pagesAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagesAllRow
	for rows.Next() {
		var i PagesAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerEmail,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pagesByUser = `-- name: PagesByUser :many
SELECT id::text, name, updated_at FROM pages WHERE user_id=$1::uuid ORDER BY updated_at DESC
`

type PagesByUserRow struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) PagesByUser(ctx context.Context, dollar_1 uuid.UUID) ([]PagesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, pagesByUser, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagesByUserRow
	for rows.Next() {
		var i PagesByUserRow
		if err := rows.Scan(&i.ID, &i.Name, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pagesWithOwners = `-- name: PagesWithOwners :many
SELECT p.id::text AS id, p.name, u.id::text AS owner_id, u.email AS owner_email, p.updated_at
FROM pages p JOIN users u ON u.id=p.user_id
ORDER BY p.updated_at DESC
`

type PagesWithOwnersRow struct {
	ID         string    `json:"id"`
	Name       string    `json:"name"`
	OwnerID    string    `json:"owner_id"`
	OwnerEmail string    `json:"owner_email"`
	UpdatedAt  time.Time `json:"updated_at"`
}

func (q *Queries) PagesWithOwners(ctx context.Context) ([]PagesWithOwnersRow, error) {
	rows, err := q.db.QueryContext(ctx, pagesWithOwners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagesWithOwnersRow
	for rows.Next() {
		var i PagesWithOwnersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.OwnerEmail,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
